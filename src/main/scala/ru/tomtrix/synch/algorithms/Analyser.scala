package ru.tomtrix.synch.algorithms

import scala.Some
import ru.tomtrix.synch._
import ru.tomtrix.synch.SafeCode._
import ru.tomtrix.synch.structures._
import ru.tomtrix.synch.ApacheLogger._

/**
 * Analyzer is an intellegent wrapper on Optimistic Synchronizator
 */
trait Analyser[T <: Serializable] extends Loggable { self: Simulator[T] =>
  /** locking event for Algorithm#2 (tuple: causedBy -> waitFor) */
  var lockingEvent: Option[(AgentEvent, AgentEvent)] = None

  /**
   * You should implement it so that simulator is suspended when the argument is true or resumed otherwise
   * @param suspend a flag whether to suspend or resume simulation
   */
  def suspendModelling(suspend: Boolean)

  /**
   * You should implement it so that it returns a set of events generated by <b>e</b>
   * @param e time-event
   * @return array of new generated events
   */
  def simulateStep(e: TimeEvent): Array[TimeEvent]

  /**
   * You should implemet it so that for each event it matches the corresponding actor name
   * @param e agent event
   * @return actor name
   */
  def getActorName(e: AgentEvent): String

  /**
   * Force the analyzer to inspect the event (Algorithm#2)
   * <br>P.S. When overriding put <b>super.commitEvent</b> to the end of the body
   * @param e time-event
   */
  def commitEvent(e: TimeEvent) {
    Knowledge cause e.event foreach { w =>
      if (getActorName(e.event) != actorname) suspend(e.event, w)
    }
  }

  /**
   * Handles [[ru.tomtrix.synch.structures.LockRequest LockRequest]] messages
   * @param m lock request
   */
  final def handleLockRequest(m: LockRequest) {
    logger debug "LockRequest received"
    lockingEvent foreach {t => sendMessage(m.sender, LockResponse(actorname))}
  }

  /**
   * Handles [[ru.tomtrix.synch.structures.LockResponse LockResponse]] messages
   */
  final def handleLockResponse() {
    logger debug "LockResponse received :( Force resuming..."
    resume()
  }

  /**
   * Checks whether it is necessary to resume the simulation
   * @param m message that might contain the event that would release the lock
   */
  final def checkUpMessage(m: EventMessage) {
    for {
      lock <- lockingEvent if m.timeevent.event == lock._2
    } resume()
  }

  /**
   * Resumes the simulation by reason of that a simulator sends an Antimessage with locking event
   * @param m Antimessage that causes the resuming
   */
  final def resumeByAntimessage(m: AntiMessage) {
    for {
      lock <- lockingEvent if m.eventMessage.timeevent.event == lock._1
    } {resume(); logger debug s"Resuming by $m"}
  }

  /**
   * Entry point to Algorithm#3. Checks whether the "event-from-the-past" is safe
   * @param e time-event
   * @return if event is safe so that it may be handled without rollbacks
   */
  final def isOK(e: TimeEvent): Boolean = {
    log"Проверим событие $e"
    val result = if (isIndependent(e)) {log"Event is independent!"; true}
    else if (isSafe(e)) runPseudoEvent(e)
    else false
    log"Общий итог = $result"
    result
  }

  /**
   * Suspends the simulation by the Algorithm#2
   * @param causedBy event that causes the lock
   * @param waitFor event that could release the lock
   */
  private def suspend(causedBy: AgentEvent, waitFor: AgentEvent) {
    lockingEvent = Some(causedBy -> waitFor)
    logger debug s"Modelling is suspended! Detected: $causedBy; waiting for: $waitFor"
    suspendModelling(suspend = true)
    sendMessage(getActorName(causedBy), LockRequest(actorname))
  }

  /**
   * Resumes the simulation
   */
  private def resume() {
    suspendModelling(suspend = false)
    lockingEvent = None
  }

  /**
   * @param e time-event
   * @return if the event is independent (i.e. it doesn't generate new events)
   */
  private def isIndependent(e: TimeEvent): Boolean = Knowledge isIndependent e.event

  /**
   * @param cur event1
   * @param that event2
   * @return if event1 correlates with event2
   */
  private def correlate(cur: AgentEvent, that: AgentEvent): Boolean = cur.patiens == that.patiens

  /**
   * @param e time-event
   * @return if the event would be handled on the local machine
   */
  private def isLocal(e: AgentEvent): Boolean = getActorName(e) == actorname

  /**
   * Checks whether the event is safe to be handled without rollbacks (Algorithm#3)
   * @param e time-event
   * @return if the event is safe
   */
  private def isSafe(e: TimeEvent): Boolean = {
    safe {
      synchronized {
        logger debug s"Проверяем, безопасно ли событие $e"
        // если событие "stateless", то оно априори безопасно
        if (Knowledge isStateless e.event) {log"Event is stateless"; true}
        else {
          // просматриваем стек состояний (в направлении "в прошлое") с вершины до t = e.t
          var result = true
          var storage: List[(TimeEvent, Array[Byte])] = Nil
          var q = stateStack peek()
          while (result && q != null)
            q = if (q._1.t < e.t) null
            else {
              if (isLocal(q._1.event) && correlate(e.event, q._1.event))
                result = false
              storage ::= stateStack pop()
              stateStack peek()
            }
          // заполняем стек обратно
          for {a <- storage}
            stateStack push a
          // return
          logger debug s"TimeEvent is save = $result"
          result
        }
      }
    } getOrElse false
  }

  /**
   * Simulates the event <b>e</b> leading to that new events are generated, and checks recursively
   * whether those events are safe  (Algorithm#3)
   * @param e time-event
   * @return if the event and its descendants are safe
   */
  private def runPseudoEvent(e: TimeEvent): Boolean = {
    logger debug s"Запуск события $e"
    val events = simulateStep(e).toSeq
    logger debug s"Были порождены следующие события: $events"
    val lst = for {
      event <- events if event.t < getTime
    } yield isOK(event)
    lst forall {b => b}
  }
}
